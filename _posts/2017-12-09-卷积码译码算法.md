---
layout: post
title: Viterbi算法和BCJR算法
date: 2017-12-09
description: 译码算法
tag: 译码算法
---

Viterbi算法是最大似然译码（ML）因此码字的误码率是被最小化的，而BCJR算法属于最大后验概率译码其信息位误码率被最小化。

# 最大似然译码

[ML](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1 "https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1")

## 似然函数

[似然函数](https://zh.wikipedia.org/wiki/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0 "https://zh.wikipedia.org/wiki/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0")
<br />
**概率**用于在已知一些参数的情况下，预测接下来的观测所得到的结果，而**似然性**则是用于在已知某些观测所得到的结果时，对有关事物的性质的参数进行估计。
<br />
因此基于这种意义，似然函数可以理解为条件概率的逆反运算。
<br />例如在已知参数B时，事件A发生的概率表示为:

$$\left. {\begin{array}{*{20}{c}}
  {compare(SM_i^n)} \\ 
  {add(SM_i^n + BM_{ik}^{n + 1})} 
\end{array}} \right\}get(SM_k^{n + 1})$$

$$P(A|B) = {P(A,B) \over P(B)}(1.1)$$

通过贝叶斯定理，

$$P(B|A) = {P(A,B)P(B) \over P(A)}(1.2)$$

如果A,B表示两个事件则公式(1.1)表示在事件B发生的条件下发生事件A的概率，而公式(1.2)则表示在事件A发生的条件下发生事件B的概率。也可以反过来构造表示似然性，在已知事件A发生的条件下，运用似然函数，估计参数B的可能性。
在形式上而言，似然函数也是一种条件概率函数，只不过所关注的变量改变了：表示在事件A发生的条件下，参数B是b的可能性。并且似然函数乘以一个正的常数之后仍然是似然函数

$$L(B=b|A)=\alpha P(A|B=b),\alpha > 0$$