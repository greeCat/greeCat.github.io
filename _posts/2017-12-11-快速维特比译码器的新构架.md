---
layout: post
title: 快速维特比译码器的新架构
date: 2017-12-11
description: communication
tag: 译码算法
tag: Viterbi
---

[Lee I, Sonntag J L. A new architecture for the fast Viterbi algorithm[J]. IEEE transactions on communications, 2003, 51(10): 1624-1628.](http://ieeexplore.ieee.org/abstract/document/1237430/ "http://ieeexplore.ieee.org/abstract/document/1237430/")

# 摘要

为快速实现Viterbi算法采用了新型构架，使得传统的串行方式（累加-->比较-->筛选）改为平行处理(增速33%)，当然硬件实现的时候需要付出更大的面积。
通过增加状态数避免不同分支度量的状态转移到相同的状态上，通过这种方法规避了需要先完成累加才能得到对应的路径度量值，最后根据对比路径度量值的大小得到对应的最大似然路径。

因为$SM_k^{(n + 1)} = SM_i^n + BM_{ik}^n$,经过增加状态的处理之后首先能够在$n+1$时刻到达$k$状态的分支度量$BM_{jk}^n$是相等的，因此在筛选其各自路径度量大小等同一次筛选其在$n$时刻的路径度量。
因此整个操作的过程由原来的顺序执行方式（累加-->比较-->筛选）改变为目前的并行处理方式。

$$\left. {\begin{array}{*{20}{c}}
  {compare(SM_i^n)} \\ 
  {add(SM_i^n + BM_{ik}^{n })} 
\end{array}} \right\}get(SM_k^{n + 1})$$

# 和传统Viterbi算法构架的区别

使用传统架构需要首先从数据存储器中读取当前时刻$n$对应的状态$i$其所对应的分支度量 $SM_i^n$，将其和当前的分支度量$BM_{ik}^{n }$相加，得到下一时刻$n+1$的路径度量$SM_k^{n + 1}$，完成所有下一时刻的路径度量计算之后需要将这些数据全部存储在数据存储器中。当完成在当前时刻$n$对应的状态$i$的$n+1$时刻的路径度量存储之后，计算在当前时刻$n$对应的状态$j$下其在时刻$n+1$路径度量，并进行存储。完成当前时刻$n$下所有状态对应的时刻$n+1$的路径度量之后。从数据存储器中读取对应的*路径度量*进行比较之后得到最小的路径度量值（当路径度量值最小值则表示其对应的路径具备最大似然），并将最小路径度量值存储值数据存储器中对应位置进行存储，之后进行下一时刻的分支度量以及路径度量计算，直至达到预设译码深度后，依旧更加路径度量甄选出幸存路径。

快速架构的Viterbi算法其与传统Viterbi算法的最大不同之处在于其所采用的add-compare-selet(ACS)实现了并行操作。结合上文中关于传统Viterbi算法的介绍可知传统算法采取先计算路径度量再进行路径度量比较最后完成路径度量筛选的顺序操作。而在快速构架的Viterbi算法中首先进行的操作时按照一定的规则从数据存储器中获取具备相同分支度量$BM_{ik}^{n }==BM_{jk}^{n }$的路径度量$SM_i^n$和$SM_j^n$之后同时进行$n$时刻的路径度量比较和$n+1$时刻的路径度量计算，最后根据$n$时刻的路径度量比较结果选择$n+1$时刻对应的路径度量，并将其存储在数据存储器中对应位置。

快速架构中为获取的从$n$时刻到达$n+1$时刻的路径度量需要从数据存储其中获取的$n$时刻路径度量的数目为$2^{m-1+n+1-n}$次
**（m为编码器约束长度）**，
以及需要$2^{m-1}*2^k$个
**（k为编码器输入长度）**
$n$时刻分支度量，需要进行的比较为$2^{m-1}$次每次参与比较的$n$时刻路径度量的数目为$2^{n+1-n}$个。需要进行的加法次数为$2^{m-1}*2^{n+1-n}*2^k$。（比较、加法并行执行）  
````
    从数据存储器中获取路径度量数据-->比较、筛选路径度量-->将新路径度量存储值数据存储器对应位置
                               -->计算新路径度量
````
传统Viterbi算法中需要获取的$n$时刻路径度量的数目为$2^{m-1}$次，需要$2^{m-1}*2^k$个**（k为编码器输入长度）**$n$时刻分支度量，需要进行的加法运算为$2^{m-1}*2^k$，完成所有路径度量的计算之后在进行比较，这里的比较情况根据实际情况变化。（顺序执行）

    从数据存储器取路径度量数据-->将计算路径度量-->比较、筛选之后的路径度量-->存储值数据存储器对应位置

